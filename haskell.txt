https://www.haskell.org/
http://www.haskell.ru/

онлайн-компилятор
	http://codepad.org/
GHC
	https://www.haskell.org/ghc/
Книга ebook
	https://nnmclub.to/forum/viewtopic.php?t=1409245
GUI
	https://habr.com/ru/company/timeweb/blog/666280/	

Haskel должен был помочь людям изучать ленивость в языках программирования. Это стратегия, когда вычисления откладываются до тех пор, пока они не понадобятся
На Haskell пишут компиляторы для других языков и для самого Haskell, а еще банковский софт
В финтехе Haskell используется потому, что это очень безопасный язык: у него отдельная группа концепций, которые как на уровне типов, так и на уровне значений хорошо между собой сочетаются

расширения для 1С?

причины для его изучения:
	- получение навыков программирования на Haskell сделает вас более сильным программистом в целом (выше среднего)
	- Haskell принуждает вас писать безопасный функциональный код, а также аккуратно моделировать ваши задачи
	- научит вас правильнее рассуждать об абстракциях и предотвращать потенциальные ошибки в любых языках программирования

----
Установка:
	www.haskell.org/downloads#platform -- устарело, все установил в ручную
Кириллизация:
	https://ru.stackoverflow.com/questions/1024393/Юникод-с-помощью-unescaping-print
	
	cabal install --lib unescaping-print
	:set -interactive-print=UnescapingPrint.uprint
	
Функции	
	это отображения из множества иксов в множество игреков

	все функции должны принмиать аргумент
	все функции должны возвращать значение
	функция возвращает одно и то же значение для одного и того же аргумента (ссылочная прозрачность)
	
	в системе лямбда-исчислений вы выражаете все через функции
	
	цель функционального программирования: дать программисту всю мощь математики
	
	программы безопасны тогда, когда они ведут себя так как вы ожидаете( без побочных эфектов выражающихся в изменении не явно доступного через окружение состояния ) 
	
	переменные можно инициализировать, но нельзя переприсваивать (иммутабельность) (м) можно в другом контексте, области видимости
	
	функция без имени, анонимная, называется лямбда-функцией
		это выражение, фрагмент кода, который может существовать сам по себе
		каждый раз при создании функции, именованной или неименованной, создается новая область видимости, представляющая контекст в котором определены переменные
	
	Функции, как значения первого класса:
		функцию можно присвоить значению переменной, передать как аргумент, вернуть как результат
	
	если функции в целом одинаковы, а отличаются лишь некоторым небольшим поведением - это называется общим вычислительным шаблоном, который можно обобщить

	в haskell вызовы функций всегда вычисляются перед операциями

	Кортеж - это тип наподобие списка, но он может содержать значения различных типов и имеет фиксированный размер (м) аналог фиксированного масива в 1С	
	
	замыкания - когда вы захватываете некоторое значение в лямбда-функцию, это называется замыкание
		прим. можем создавать функции динамически, т.е. создавать функции функциями
		(м) параметр переданный в одну функцию захватывается другой функцией
		
	частичное применение 
		при вызове любой функции с количеством аргументов меньше требуемого вы получаете новую функцию, принимающую оставшиеся аргументы 
		
	Списки - это единственная наиболее важная структура данных в функциональном программировании (м) поток?
		по своей природе рекурсивны, т.к. список - это либо пустой список, либо элемент за которым следует список 
		
		главными компонентами оказываются
			функция голова (head) 	-- возвращает первый элемент списка (элемент)
			функция хвост (tail) 	-- возвращает остальную часть списка, идущую после головы (другой список)
			пустой список [] 		-- можно воспринимать как маркер конца
				
		у пустого списка нет ни головы ни хвоста, вызов head или tail на пустом списке даст ошибку 		
			
		:  -- конструирование списка
			1:[] == [1]
			1:2:3:4:[] == [1,2,3,4]
			
			список - это всегда значение, присоединённое к другому списку (который может быть пустым)
			1:[2,3,4] == [1,2,3,4]

		строки являются синтаксическим сахаром для списка символов (символ обозначается одинарными кавычками)	
			
		"hi" == ['h','i'] == 'h':'i':[]	

		все элементы списка должны быть одного типа	
			
		если вы хотите соединить два списка, то вам нужно сконкатенировать их с помощью операции ++

	Ленивые вычисления - это вычисления, в которых код не вычисляется до того момента, пока он не потребуется		
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			